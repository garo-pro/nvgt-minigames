/* form.nvgt - audio form originally taken from bgt, but now heavily modified
 *
 * NVGT - NonVisual Gaming Toolkit
 * Copyright (c) 2022-2024 Sam Tupy
 * https://nvgt.gg
 * original form.bgt Copyright (C) 2010-2014 Blastbay Studios
 * This software is provided "as-is", without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.
 * Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:
 * 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
*/

#include "speech.nvgt"

/*
modified by Sam Tupy:
audioform_input_disable_ralt
added search text functionality
control+arrows now moves by more than just space
added get_line_number, get_line_column, and set_line functions
added the ct_form control type
added the ct_keyboard_area control type
changed some text field cosmetics
added multiline_enter as an optional arg to create_input_box to make shift or control+enter insert a new line while enter still activates the default control
adds focus_silently and focus_interrupt functions
adds set_default_controls function
list items can now have ID strings apart from the item names (add_list_item extra param, get_list_item_id, edit_list_item_id)
shortcut announcement now respects the separate_attributes parameter
fixed absolutely critical multiline bug that somehow made it into BGT's release
pasting text now moves cursor to end of pasted text
added set_keyboard_echo function
added set_default_keyboard_echo function
finished keyboard echo modes
added complete keyboard repeating
added multi-letter-navigation in lists with a function called set_list_multinavigation that lets you enable or disable it for both letters and numbers
fixed and changed anouncement of checkboxes
deleting text now calls input_box_speak with ignore_echo_flag set to true
delete_speech_text now empty by default and no space is added to text string if this is true (if you press backspace or delete you know your deleting)
fixed selections speaking the contents of password fields
pasting in text fields now just says text pasted instead of anouncing what you have pasted, both to decrease annoyance and to make password fields secure
create_list now has a repeat_boundary_items argument, which if true causes pressing up or down arrows on list boundaries to repeat the first or last item depending
set_list_position now has speak_new_item argument (false by default)
edit_list_item had taken code from add_list_item thus not allowing item editing if the list was full and also allowing a runtime error if attempting to edit an item 1 greater than the list length, these bugs have been fixed
added the ct_slider control type, create_slider, get_slider, set_slider, get_slider_text_value, set_slider_text_value, clear_slider_text_values
added prespeech callback
added event callback
*/

//constants
enum control_types {
	ct_button = 0,
	ct_input,
	ct_checkbox,
	ct_progress,
	ct_status_bar,
	ct_list,
	ct_slider,
	ct_form,
	ct_keyboard_area,
	ct_link
}
//form_errors
enum audioform_errorcodes {
	form_error_none = 0,
	form_error_invalid_index,
	form_error_invalid_control,
	form_error_invalid_value,
	form_error_invalid_operation,
	form_error_no_window,
	form_error_window_full,
	form_error_text_too_long,
	form_error_list_empty,
	form_error_list_full,
	form_error_invalid_list_index,
	form_error_control_invisible,
	form_error_no_controls_visible
}
//text entry speech flags
enum text_entry_speech_flags {
	textflag_none = 0,
	textflag_characters,
	textflag_words,
	textflag_characters_words
}
//Text edit modes
enum text_edit_mode_constants {
	edit_mode_replace = 0,
	edit_mode_trim_to_length,
	edit_mode_append_to_end
}
//types of update events that can be received by controls
enum control_event_type {
	event_none = 0,
	event_focus,
	event_list_cursor,
	event_text_cursor,
	event_button,
	event_checkbox,
	event_slider
}
//characters that should be considered word boundaries.
string audioform_word_separators = "_ .,!\\\"/[{()}]=\n";
//prespeech callback, if set the given function will be called right before the form speaks.
funcdef void prespeech_callback(audio_form@ f);
//control event callback
funcdef int on_control_event_callback(audio_form@ f, int c, control_event_type event, dictionary@ args);

//can make this a member of the audio form class as soon as even one person suggests seriously wanting to change on a form by form basis I guess
bool audioform_input_disable_ralt = true;
int audioform_keyboard_echo = textflag_characters;
//main window class
class audio_form {
	bool active;
	bool speak_control_attributes_separately;
	int subform_control_index = -1;
	on_control_event_callback@ event_callback = null;
	utility_form@ utility_form = null;
	dictionary utility_form_data;
	//constructor
	audio_form() {
		reset();
	}
	void create_window() {
		create_window("", false, false, true);
	}
	void create_window(string window_title, bool change_screen_title = true, bool say_dialog = true, bool silent = false) {
		form_error = 0;
		if (!active)
			get_characters();
		active = true;
		if (!silent && change_screen_title && window_title != "")
			show_window(window_title);
		/*if(@ui_speech==null)
		{
		tts_voice temp_voice;
		@ui_speech=temp_voice;
		}*/
		if (window_title == "" || silent)
			return;
		if (speak_control_attributes_separately) {
			speak(window_title, true);
			if (say_dialog)
				speak("Dialog", false);
		} else {
			if (say_dialog)
				speak(window_title + " Dialog", true);
			else
				speak(window_title, true);
		}
	}
	bool set_checkbox_mark(int control_index, bool checked) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_checkbox) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_index].checked = checked;
		return true;
	}
	bool set_custom_type(int control_index, string custom_type)
		{
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (custom_type.empty()) {
			form_error = form_error_invalid_value;
			return false;
		}
		c_form[control_index].custom_type = custom_type;
		return true;
	}
	string get_custom_type(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return "";
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return "";
		}
		return c_form[control_index].custom_type;
	}
	bool has_custom_type(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		return !c_form[control_index].custom_type.empty();
	}
	bool set_subform(int control_index, audio_form@ f) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_form) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		@c_form[control_index].subform = @f;
		if (@f != null) {
			f.subform = true;
			f.subform_control_index = control_index;
		}
		return true;
	}
	bool set_output_mode(int speech_output, bool progress_bars_beep = false) {
		form_error = 0;
		if ((speech_output < 0) || (speech_output > 4))
			return false;
		this.speech_output = speech_output;
		for (int counter = 0; counter < c_form.length(); counter++) {
			c_form[counter].speech_output = speech_output;
			c_form[counter].beeping_progress = progress_bars_beep;
			if (c_form[counter].beeping_progress) {
			}
		}
		return true;
	}
	int create_input_box(string caption, string default_text = "", string password_mask = "", int maximum_length = 0, bool read_only = false, bool multiline = false, bool multiline_enter = true) {
		form_error = 0;
		if (active_controls >= 50) {
			form_error = form_error_window_full;
			return -1;
		}
		control_counter++;
		active_controls++;
		c_form.resize(control_counter + 1);
		c_form[control_counter].type = ct_input;
		@c_form[control_counter].event_callback = event_callback;
		c_form[control_counter].hotkey = shortcut(caption);
		c_form[control_counter].hotkey_letter = shortcut_letter(caption);
		c_form[control_counter].caption = caption.replace("&", "", true);
		c_form[control_counter].visible = true;
		c_form[control_counter].enabled = true;
		c_form[control_counter].speech_output = speech_output;
		if ((maximum_length > 0) && (default_text.length() > maximum_length)) {
			default_text = default_text.substr(0, maximum_length);
			form_error = form_error_text_too_long;
		}
		c_form[control_counter].text = default_text;
		c_form[control_counter].cursor = 0;
		c_form[control_counter].sel_start = -1;
		c_form[control_counter].sel_end = -1;
		c_form[control_counter].max_length = maximum_length;
		c_form[control_counter].password_mask = password_mask.substr(0, 1);
		c_form[control_counter].read_only = read_only;
		c_form[control_counter].multiline = multiline;
		c_form[control_counter].multiline_enter = multiline_enter;
		c_form[control_counter].echo_flag = default_echo_flag;
		@c_form[control_counter].ui_speech = ui_speech;
		return control_counter;
	}
	int create_list(string caption, int maximum_items = 0, bool multiselect = false, bool repeat_boundary_items = false) {
		form_error = 0;
		if (active_controls >= 50) {
			form_error = form_error_window_full;
			return -1;
		}
		control_counter++;
		active_controls++;
		c_form.resize(control_counter + 1);
		c_form[control_counter].type = ct_list;
		@c_form[control_counter].event_callback = event_callback;
		c_form[control_counter].hotkey = shortcut(caption);
		c_form[control_counter].hotkey_letter = shortcut_letter(caption);
		c_form[control_counter].caption = caption.replace("&", "", true);
		c_form[control_counter].visible = true;
		c_form[control_counter].enabled = true;
		c_form[control_counter].max_length = maximum_items;
		c_form[control_counter].list_multiselect = multiselect;
		c_form[control_counter].list_repeat_boundary_items = repeat_boundary_items;
		c_form[control_counter].speech_output = speech_output;
		@c_form[control_counter].ui_speech = ui_speech;
		return control_counter;
	}
	int create_tab_panel(string caption, int maximum_items = 0, bool repeat_boundary_items = false) {
		form_error = 0;
		if (active_controls >= 50) {
			form_error = form_error_window_full;
			return -1;
		}
		control_counter++;
		active_controls++;
		c_form.resize(control_counter + 1);
		c_form[control_counter].type = ct_list;
		@c_form[control_counter].event_callback = event_callback;
		c_form[control_counter].hotkey = shortcut(caption);
		c_form[control_counter].hotkey_letter = shortcut_letter(caption);
		c_form[control_counter].caption = caption.replace("&", "", true);
		c_form[control_counter].visible = true;
		c_form[control_counter].enabled = true;
		c_form[control_counter].max_length = maximum_items;
		c_form[control_counter].list_multiselect = false;
		c_form[control_counter].list_repeat_boundary_items = repeat_boundary_items;
		c_form[control_counter].list_is_tab_panel = true;
		c_form[control_counter].speech_output = speech_output;
		@c_form[control_counter].ui_speech = ui_speech;
		return control_counter;
	}
	int create_button(string caption, bool primary = false, bool cancel = false, bool overwrite = true) {
		form_error = 0;
		if (active_controls >= 50) {
			form_error = form_error_window_full;
			return -1;
		}
		control_counter++;
		active_controls++;
		c_form.resize(control_counter + 1);
		c_form[control_counter].type = ct_button;
		@c_form[control_counter].event_callback = event_callback;
		c_form[control_counter].hotkey = shortcut(caption);
		c_form[control_counter].hotkey_letter = shortcut_letter(caption);
		c_form[control_counter].caption = caption.replace("&", "", true);
		c_form[control_counter].visible = true;
		c_form[control_counter].enabled = true;
		c_form[control_counter].speech_output = speech_output;
		@c_form[control_counter].ui_speech = ui_speech;
		set_button_attributes(control_counter, primary, cancel, overwrite);
		return control_counter;
	}
	int create_progress_bar(string caption, int speak_interval = 5, bool speak_global = true) {
		form_error = 0;
		if (active_controls >= 50) {
			form_error = form_error_window_full;
			return -1;
		}
		control_counter++;
		active_controls++;
		c_form.resize(control_counter + 1);
		c_form[control_counter].type = ct_progress;
		@c_form[control_counter].event_callback = event_callback;
		c_form[control_counter].hotkey = shortcut(caption);
		c_form[control_counter].hotkey_letter = shortcut_letter(caption);
		c_form[control_counter].caption = caption.replace("&", "", true);
		c_form[control_counter].visible = true;
		c_form[control_counter].enabled = true;
		c_form[control_counter].speak_interval = speak_interval * 1000;
		c_form[control_counter].speak_global = check_globals(speak_global);
		c_form[control_counter].speech_output = speech_output;
		@c_form[control_counter].ui_speech = ui_speech;
		return control_counter;
	}
	int create_slider(string caption, double default_value = 50, double minimum_value = 0, double maximum_value = 100, string text = "", double step_size = 1) {
		form_error = 0;
		if (active_controls >= 50) {
			form_error = form_error_window_full;
			return -1;
		}
		control_counter++;
		active_controls++;
		c_form.resize(control_counter + 1);
		c_form[control_counter].type = ct_slider;
		@c_form[control_counter].event_callback = event_callback;
		c_form[control_counter].hotkey = shortcut(caption);
		c_form[control_counter].hotkey_letter = shortcut_letter(caption);
		c_form[control_counter].caption = caption.replace("&", "", true);
		c_form[control_counter].visible = true;
		c_form[control_counter].enabled = true;
		c_form[control_counter].slider_value = default_value;
		c_form[control_counter].slider_minimum_value = minimum_value;
		c_form[control_counter].slider_maximum_value = maximum_value;
		c_form[control_counter].slider_step_size = step_size;
		c_form[control_counter].text = text;
		c_form[control_counter].speech_output = speech_output;
		@c_form[control_counter].ui_speech = ui_speech;
		return control_counter;
	}
	int create_status_bar(string caption, string text) {
		form_error = 0;
		if (active_controls >= 50) {
			form_error = form_error_window_full;
			return -1;
		}
		control_counter++;
		active_controls++;
		c_form.resize(control_counter + 1);
		c_form[control_counter].type = ct_status_bar;
		@c_form[control_counter].event_callback = event_callback;
		c_form[control_counter].hotkey = shortcut(caption);
		c_form[control_counter].hotkey_letter = shortcut_letter(caption);
		c_form[control_counter].caption = caption.replace("&", "", true);
		c_form[control_counter].visible = true;
		c_form[control_counter].enabled = true;
		c_form[control_counter].text = text;
		c_form[control_counter].speech_output = speech_output;
		@c_form[control_counter].ui_speech = ui_speech;
		return control_counter;
	}
	int create_keyboard_area(string caption) {
		form_error = 0;
		if (active_controls >= 50) {
			form_error = form_error_window_full;
			return -1;
		}
		control_counter++;
		active_controls++;
		c_form.resize(control_counter + 1);
		c_form[control_counter].type = ct_keyboard_area;
		@c_form[control_counter].event_callback = event_callback;
		c_form[control_counter].hotkey = shortcut(caption);
		c_form[control_counter].hotkey_letter = shortcut_letter(caption);
		c_form[control_counter].caption = caption.replace("&", "", true);
		c_form[control_counter].visible = true;
		c_form[control_counter].enabled = true;
		c_form[control_counter].speech_output = speech_output;
		@c_form[control_counter].ui_speech = ui_speech;
		return control_counter;
	}
	int create_subform(string caption, audio_form@ f) {
		if (@f != null) f.subform = true;
		form_error = 0;
		if (active_controls >= 50) {
			form_error = form_error_window_full;
			return -1;
		}
		control_counter++;
		active_controls++;
		c_form.resize(control_counter + 1);
		c_form[control_counter].type = ct_form;
		@c_form[control_counter].event_callback = event_callback;
		c_form[control_counter].hotkey = shortcut(caption);
		c_form[control_counter].hotkey_letter = shortcut_letter(caption);
		c_form[control_counter].caption = caption.replace("&", "", true);
		c_form[control_counter].visible = true;
		c_form[control_counter].enabled = true;
		c_form[control_counter].speech_output = speech_output;
		@c_form[control_counter].ui_speech = ui_speech;
		@c_form[control_counter].subform = f;
		if (@f != null) f.subform_control_index = control_counter;
		return control_counter;
	}
	int create_checkbox(string caption, bool initial_value = false, bool read_only = false) {
		form_error = 0;
		if (active_controls >= 50) {
			form_error = form_error_window_full;
			return -1;
		}
		control_counter++;
		active_controls++;
		c_form.resize(control_counter + 1);
		c_form[control_counter].type = ct_checkbox;
		@c_form[control_counter].event_callback = event_callback;
		c_form[control_counter].hotkey = shortcut(caption);
		c_form[control_counter].hotkey_letter = shortcut_letter(caption);
		c_form[control_counter].caption = caption.replace("&", "", true);
		c_form[control_counter].visible = true;
		c_form[control_counter].enabled = true;
		c_form[control_counter].checked = initial_value;
		c_form[control_counter].read_only = read_only;
		c_form[control_counter].speech_output = speech_output;
		@c_form[control_counter].ui_speech = ui_speech;
		return control_counter;
	}
	int create_link(string caption, string url) {
		form_error = 0;
		if (active_controls >= 50) {
			form_error = form_error_window_full;
			return -1;
		}
		control_counter++;
		active_controls++;
		c_form.resize(control_counter + 1);
		c_form[control_counter].type = ct_link;
		@c_form[control_counter].event_callback = event_callback;
		c_form[control_counter].hotkey = shortcut(caption);
		c_form[control_counter].hotkey_letter = shortcut_letter(caption);
		c_form[control_counter].caption = caption.replace("&", "", true);
		c_form[control_counter].link_url = url;
		c_form[control_counter].visible = true;
		c_form[control_counter].enabled = true;
		c_form[control_counter].speech_output = speech_output;
		@c_form[control_counter].ui_speech = ui_speech;
		return control_counter;
	}
	bool activate_progress_timer(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_progress) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (c_form[control_index].speak_interval == 0) {
			form_error = form_error_invalid_value;
			return false;
		}
		if (c_form[control_index].progress_time.running == true) {
			form_error = form_error_invalid_operation;
			return false;
		}
		c_form[control_index].progress_time.resume();
		return true;
	}
	bool pause_progress_timer(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_progress) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].progress_time.running) {
			form_error = form_error_invalid_operation;
			return false;
		}
		c_form[control_index].progress_time.pause();
		return true;
	}
	bool delete_control(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_index].active = false;
		if (c_form[control_index].type == ct_progress) {
		}
		active_controls--;
		control_focus = -1;
		return true;
	}
	int monitor() {
		if (total_keys_down() < 1) return 0;
		if (@utility_form != null) {
			utility_form.monitor();
			return 0;
		}
		int start = control_focus;
		int defaults = get_default_button();
		int cancels = get_cancel_button();
		int focused = get_current_focus();
		form_error = 0;
		if ((key_pressed(KEY_LCTRL)) || (key_pressed(KEY_RCTRL)))
			stop_speech();
		if (!active) {
			form_error = form_error_no_window;
			return 0;
		}
		int autotab = 0;
		if (focused > -1 && focused <= control_counter && c_form[focused].type == ct_form && @c_form[focused].subform != null && c_form[focused].subform.get_control_count() > 0)
			autotab = c_form[focused].subform.monitor();
		if (key_repeating(KEY_TAB) || autotab != 0 && autotab < 2) {
			if ((control_counter < 0) || (key_down(KEY_LALT)) || (key_down(KEY_LGUI)) || (key_down(KEY_RALT)) || (key_down(KEY_RGUI)))
				return 0;
			if ((control_counter == 0) && (control_focus == 0))
				return autotab;
			if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT)) || autotab == -1) {
				control_focus--;
				if (control_focus < 0) {
					if (subform) {
						focus_silently(0);
						return -1;
					}
					control_focus = control_counter;
				}
				while ((c_form[control_focus].visible == false) || (c_form[control_focus].active == false) || (@c_form[control_focus].subform != null && c_form[control_focus].subform.get_control_count() < 1)) {
					control_focus--;
					if (control_focus < 0) {
						if (subform) {
							focus_silently(0);
							return -1;
						}
						control_focus = control_counter;
					}
					if (control_focus == start) {
						form_error = form_error_no_controls_visible;
						return -1;
					}
				}
				if (c_form[control_focus].type == ct_form and @c_form[control_focus].subform != null)
					c_form[control_focus].subform.focus_silently(c_form[control_focus].subform.get_control_count() - 1);
			} else {
				control_focus++;
				if (control_focus > control_counter) {
					if (subform) {
						focus_silently(0);
						return 1;
					}
					control_focus = 0;
				}
				while ((c_form[control_focus].visible == false) || (c_form[control_focus].active == false) || (@c_form[control_focus].subform != null && c_form[control_focus].subform.get_control_count() < 1)) {
					control_focus++;
					if (control_focus > control_counter) {
						if (subform) {
							focus_silently(0);
							return 1;
						}
						control_focus = 0;
					}
					if (control_focus == start) {
						form_error = form_error_no_controls_visible;
						return 1;
					}
					if (c_form[control_focus].type == ct_form and @c_form[control_focus].subform != null)
						c_form[control_focus].subform.focus_silently(0);
				}
			}
			focus(control_focus, true);
		}
		if ((cancels > -1) && (key_repeating(KEY_ESCAPE) || key_released(KEY_AC_BACK))) {
			stop_speech();
			c_form[cancels].pressed = true;
			if (subform)
				return 2;
		}
		if ((focused < 0 || c_form[focused].type != ct_keyboard_area) && (focused < 0 || ((!c_form[focused].multiline_enter || !c_form[focused].multiline) && c_form[focused].type == ct_input || c_form[focused].type == ct_button) && key_up(KEY_LCTRL) && key_up(KEY_RCTRL) && key_up(KEY_LSHIFT) && key_up(KEY_RSHIFT)) && (key_pressed(KEY_RETURN) || key_pressed(KEY_NUMPAD_ENTER) || (autotab == 3))) {
			stop_speech();
			if ((defaults == -1) && (focused > -1)) {
				if (c_form[focused].type == ct_button || c_form[focused].type == ct_link)
					c_form[focused].pressed = true;
				else if (subform)
					return 3;
			}
			if (defaults > -1) {
				if (focused == -1)
					c_form[defaults].pressed = true;
				if (focused > -1) {
					if ((c_form[focused].type != ct_button) && ((c_form[focused].type != ct_input) || (!c_form[focused].multiline || !c_form[focused].multiline_enter))) {
						c_form[defaults].pressed = true;
						if (subform)
							return 2;
					}
					if (c_form[focused].type == ct_button)
						c_form[focused].pressed = true;
				}
			}
		}
		check_shortcuts();
		check_speech_mode();
		if (control_focus == -1)
			return 0;
		check(control_focus);
		return 0;
	}
	bool focus(int control_id) {
		return focus(control_id, false);
	}
	bool focus_interrupt(int control_id) {
		return focus(control_id, true);
	}
	bool focus_silently(int control_id) {
		return focus(control_id, false, true);
	}
	bool is_disallowed_char(int control_index, string char, bool search_all = true) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		return c_form[control_index].is_disallowed_char(char, search_all);
	}
	bool is_visible(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		return c_form[control_index].visible;
	}
	bool is_enabled(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		return c_form[control_index].enabled;
	}
	bool is_read_only(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_input && c_form[control_index].type != ct_checkbox) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		return c_form[control_index].read_only;
	}
	bool is_multiline(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_input) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		return c_form[control_index].multiline;
	}
	bool is_pressed(int control_index) {
		bool temp;
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_button) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		temp = c_form[control_index].pressed;
		c_form[control_index].pressed = false;
		return temp;
	}
	bool is_checked(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_checkbox) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		return c_form[control_index].checked;
	}
	bool add_list_item(int control_index, const string& in option, int position = -1, bool selected = false, bool focus_if_first = true) {
		return add_list_item(control_index, option, "", position, selected, focus_if_first);
	}
	bool add_list_item(int control_index, const string& in option, string id, int position = -1, bool selected = false, bool focus_if_first = true) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_list) {
			form_error = form_error_invalid_control;
			return false;
		}
		if ((c_form[control_index].max_length > 0) && (c_form[control_index].max_length == c_form[control_index].list.length())) {
			form_error = form_error_list_full;
			return false;
		}
		if (position > c_form[control_index].list_length + 1) {
			form_error = form_error_invalid_list_index;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_index].list_length++;
		if ((position < 0) || (position == c_form[control_index].list_length + 1)) {
			c_form[control_index].list.resize(c_form[control_index].list.length() + 1);
			c_form[control_index].list[c_form[control_index].list_length].item = option;
			c_form[control_index].list[c_form[control_index].list_length].id = id;
			if (c_form[control_index].list_multiselect)
				c_form[control_index].list[c_form[control_index].list_length].checked = selected;
		} else {
			c_form[control_index].list.insert_at(position, list_item());
			c_form[control_index].list[position].item = option;
			c_form[control_index].list[position].id = id;
			if (c_form[control_index].list_multiselect)
				c_form[control_index].list[position].checked = selected;
		}
		if (focus_if_first && c_form[control_index].list.length() == 1)
			c_form[control_index].list_position = 0;
		return true;
	}
	bool edit_list_item(int control_index, string new_option, int position) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_list) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (position > c_form[control_index].list_length) {
			form_error = form_error_invalid_list_index;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_index].list[position].item = new_option;
		return true;
	}
	bool edit_list_item_id(int control_index, string new_id, int position) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_list) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (position > c_form[control_index].list_length) {
			form_error = form_error_invalid_list_index;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_index].list[position].id = new_id;
		return true;
	}
	bool set_default_controls(int primary, int cancel) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((primary < -1) || (primary > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if ((cancel < -1) || (cancel > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (primary > -1 && (c_form[primary].type != ct_button || !c_form[primary].active)) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (cancel > -1 && (c_form[cancel].type != ct_button || !c_form[cancel].active)) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (primary > -1)
			set_primary(primary, true, true);
		else {
			int defaults = get_default_button();
			if (defaults > -1)
				set_primary(defaults, false, true);
		}
		if (cancel > -1)
			set_cancel(cancel, true, true);
		else {
			int cancels = get_cancel_button();
			if (cancels > -1)
				set_cancel(cancels, false, true);
		}
		return true;
	}
	bool set_button_attributes(int control_index, bool primary, bool cancel, bool overwrite = true) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_button) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		set_primary(control_index, primary, overwrite);
		set_cancel(control_index, cancel, overwrite);
		return true;
	}
	bool set_list_propertyes(int control_index, bool multiselect=false, bool repeat_boundary_items=false) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_list) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_counter].list_multiselect = multiselect;
		c_form[control_counter].list_repeat_boundary_items = repeat_boundary_items;
		return true;
	}
	bool delete_list_item(int control_index, int list_index, bool reset_cursor = true, bool speak_deletion_status = true) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_list) {
			form_error = form_error_invalid_control;
			return false;
		}
		if ((list_index < 0) || (list_index > c_form[control_index].list_length)) {
			form_error = form_error_invalid_list_index;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (speak_deletion_status)
			speak(c_form[control_index].list[list_index].item + " deleted.", true);
		c_form[control_index].list.remove_at(list_index);
		c_form[control_index].list_length--;
		if (reset_cursor or c_form[control_index].list.length() < 1)
			c_form[control_index].list_position = -1;
		else {
			if (c_form[control_index].list_position >= list_index)
				c_form[control_index].list_position--;
			if (c_form[control_index].list_position < 0)
				c_form[control_index].list_position = 0;
		}
		if ((speak_deletion_status) && (c_form[control_index].list_position > -1)) {
			speak(c_form[control_index].list[get_list_position(control_index)].item, false);
			if (c_form[control_index].list[get_list_position(control_index)].checked)
				speak("Checked", false);
		}
		return true;
	}
	bool delete_list_selections(int control_index, bool reset_cursor = true, bool speak_deletion_status = true) {
		form_error = 0;
		int[] selections;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_list) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		selections = get_list_selections(control_index);
		if (speak_deletion_status) {
			if (selections.length() == 1)
				speak(c_form[control_index].list[selections[0]].item + " deleted.", true);
			else
				speak(selections.length() + " items deleted.", true);
		}
		for (int counter = 0; counter < selections.length(); counter++) {
			int current_delete = (selections[counter] - counter);
			c_form[control_index].list.remove_at(current_delete);
			c_form[control_index].list_length--;
		}
		if (reset_cursor)
			c_form[control_index].list_position = -1;
		else {
			if (c_form[control_index].list_position > c_form[control_index].list_length)
				c_form[control_index].list_position = c_form[control_index].list_length;
			if (c_form[control_index].list_position < 0)
				c_form[control_index].list_position = 0;
		}
		if ((speak_deletion_status) && (c_form[control_index].list_position > -1)) {
			speak(c_form[control_index].list[get_list_position(control_index)].item, false);
			if (c_form[control_index].list[get_list_position(control_index)].checked)
				speak("Checked", false);
		}
		return true;
	}
	bool clear_list(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_list) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_index].list.resize(0);
		c_form[control_index].list_length = -1;
		c_form[control_index].list_position = -1;
		c_form[control_index].multinav_characters = "";
		return true;
	}
	bool set_state(int control_index, bool enabled, bool visible) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_index].enabled = enabled;
		c_form[control_index].visible = visible;
		return true;
	}
	bool set_enable_go_to_index(int control_index, bool enabled) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_index].enable_go_to_index = enabled;
		return true;
	}
	bool set_disallowed_chars(int control_index, string chars, bool use_only_disallowed_chars = false, string char_disallowed_description = "") {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (chars.length() < 1)
			c_form[control_index].disallowed_chars.resize(0);
		else {
			for (uint i = 0; i < chars.length(); i++)
				c_form[control_index].disallowed_chars.insert_last(chars[i]);
		}
		c_form[control_index].use_only_disallowed_chars = use_only_disallowed_chars;
		c_form[control_index].char_disallowed_description = char_disallowed_description;
		return true;
	}
	bool set_overwrite_mode(int control_index, bool overwrite) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_input) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_index].overwrite = overwrite;
		return true;
	}
	int get_list_position(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return -1;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return -1;
		}
		if (c_form[control_index].type != ct_list) {
			form_error = form_error_invalid_control;
			return -1;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return -1;
		}
		return c_form[control_index].list_position;
	}
	bool set_list_position(int control_index, int position = -1, bool speak_new_item = false) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_list) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		if ((position < -1) || (position >= get_list_count(control_index))) {
			form_error = form_error_invalid_list_index;
			return false;
		}
		c_form[control_index].list_position = position;
		if ((speak_new_item) && (c_form[control_index].list_position > -1)) {
			speak(c_form[control_index].list[position].item, false);
			if (c_form[control_index].list[position].checked)
				speak("Checked", false);
		}
		return true;
	}
	bool set_list_multinavigation(int control_index, bool letters, bool numbers, bool nav_translate = true) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_list) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_index].multinav_letters = letters;
		c_form[control_index].multinav_numbers = numbers;
		c_form[control_index].list_nav_translate = nav_translate;
		return true;
	}
	int[]@ get_list_selections(int control_index) {
		int[] temp;
		int position;
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return temp;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return temp;
		}
		if (c_form[control_index].type != ct_list) {
			form_error = form_error_invalid_control;
			return temp;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return temp;
		}
		position = get_list_position(control_index);
		if (!c_form[control_index].list_multiselect) {
			if (position == -1)
				return temp;
			temp.insert_last(position);
			return temp;
		}
		for (int counter = 0; counter <= c_form[control_index].list_length; counter++) {
			if (c_form[control_index].list[counter].checked)
				temp.insert_last(counter);
		}
		if ((temp.length() == 0) && (position > -1))
			temp.insert_last(position);
		return temp;
	}
	bool is_list_item_checked(int control_index, int item_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_list) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (item_index > c_form[control_index].list_length) {
			form_error = form_error_invalid_list_index;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].list_multiselect) {
			form_error = form_error_invalid_control;
			return false;
		}
		return c_form[control_index].list[item_index].checked;
	}
	int[]@ get_checked_list_items(int control_index) {
		int[] temp;
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return temp;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return temp;
		}
		if (c_form[control_index].type != ct_list) {
			form_error = form_error_invalid_control;
			return temp;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return temp;
		}
		if (!c_form[control_index].list_multiselect) {
			form_error = form_error_invalid_control;
			return temp;
		}
		for (int counter = 0; counter <= c_form[control_index].list_length; counter++) {
			if (c_form[control_index].list[counter].checked)
				temp.insert_last(counter);
		}
		return temp;
	}
	int get_list_count(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return -1;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return -1;
		}
		if (c_form[control_index].type != ct_list) {
			form_error = form_error_invalid_control;
			return -1;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return -1;
		}
		return c_form[control_index].list.length();
	}
	int get_list_index_by_id(int control_index, string id) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return -1;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return -1;
		}
		if (c_form[control_index].type != ct_list) {
			form_error = form_error_invalid_control;
			return -1;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return -1;
		}
		for (int i = 0; i < c_form[control_index].list.length(); i++) {
			if (c_form[control_index].list[i].id == id)
				return i;
		}
		return -1;
	}
	string get_list_item(int control_index, int list_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return "";
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return "";
		}
		if (c_form[control_index].type != ct_list) {
			form_error = form_error_invalid_control;
			return "";
		}
		if ((list_index < 0) || (list_index > c_form[control_index].list_length)) {
			form_error = form_error_invalid_list_index;
			return "";
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return "";
		}
		return c_form[control_index].list[list_index].item;
	}
	string get_list_item_id(int control_index, int list_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return "";
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return "";
		}
		if (c_form[control_index].type != ct_list) {
			form_error = form_error_invalid_control;
			return "";
		}
		if ((list_index < 0) || (list_index > c_form[control_index].list_length)) {
			form_error = form_error_invalid_list_index;
			return "";
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return "";
		}
		return c_form[control_index].list[list_index].id;
	}
	bool set_caption(int control_index, string caption) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_index].hotkey = shortcut(caption);
		c_form[control_index].hotkey_letter = shortcut_letter(caption);
		c_form[control_index].caption = caption.replace("&", "", true);
		return true;
	}
	string get_caption(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return "";
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return "";
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return "";
		}
		return c_form[control_index].caption;
	}
	bool set_event_callback(int control_index, on_control_event_callback@ event_callback) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		@c_form[control_index].event_callback = event_callback;
		return true;
	}
	int get_default_button() {
		if (!active) {
			form_error = form_error_no_window;
			return -1;
		}
		for (int counter = 0; counter < c_form.length(); counter++) {
			if (c_form[counter].primary)
				return counter;
		}
		return -1;
	}
	int get_cancel_button() {
		if (!active) {
			form_error = form_error_no_window;
			return -1;
		}
		for (int counter = 0; counter < c_form.length(); counter++) {
			if (c_form[counter].cancel)
				return counter;
		}
		return -1;
	}
	string get_password_mask(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return "";
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return "";
		}
		if (c_form[control_index].type != ct_input) {
			form_error = form_error_invalid_control;
			return "";
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return "";
		}
		return c_form[control_index].password_mask;
	}
	string get_text(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return "";
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return "";
		}
		if ((c_form[control_index].type != ct_input) && (c_form[control_index].type != ct_status_bar)) {
			form_error = form_error_invalid_control;
			return "";
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return "";
		}
		return c_form[control_index].text.replace("\n", "\r\n", true);
	}
	const string& get_text_reference(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return "";
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return "";
		}
		if ((c_form[control_index].type != ct_input) && (c_form[control_index].type != ct_status_bar)) {
			form_error = form_error_invalid_control;
			return "";
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return "";
		}
		return c_form[control_index].text;
	}
	bool set_text(int control_index, string new_text) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if ((c_form[control_index].type != ct_input) && (c_form[control_index].type != ct_status_bar) && (c_form[control_index].type != ct_slider)) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_index].text = new_text.replace("\r", "", true);
		c_form[control_index].cursor = 0;
		c_form[control_index].sel_start = -1;
		c_form[control_index].sel_end = -1;
		return true;
	}
	bool select_text(int control_index, int sel_start = -1, int sel_end = -1) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if ((c_form[control_index].type != ct_input)) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_index].sel_start = sel_start;
		if (sel_start >= 0 && sel_end < 0)
			sel_end = c_form[control_index].text.length() - 1;
		c_form[control_index].sel_end = sel_end;
		return true;
	}
	bool add_text(int control_index, string new_text, int position = -1) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if ((c_form[control_index].type != ct_input) && (c_form[control_index].type != ct_status_bar)) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (position > c_form[control_index].text.length()) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (position == -1)
			position = c_form[control_index].text.length();
		c_form[control_index].add_silent(new_text, position);
		return true;
	}
	bool edit_text(int control_index, string new_text, int position, int edit_mode = edit_mode_trim_to_length) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if ((c_form[control_index].type != ct_input) && (c_form[control_index].type != ct_status_bar)) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_index].edit_silent(new_text, position, edit_mode);
		return true;
	}
	int get_line_number(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return -1;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return -1;
		}
		if (c_form[control_index].type != ct_input || !c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return -1;
		}
		return c_form[control_index].get_line_number();
	}
	int get_line_column(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return -1;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return -1;
		}
		if (c_form[control_index].type != ct_input || !c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return -1;
		}
		return c_form[control_index].get_line_column();
	}
	bool set_line(int control_index, int line, int col = 1, bool speak_result = false) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_input || !c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		return c_form[control_index].set_line(line, col, !speak_result);
	}
	bool search(int control_index, const string& in text, int dir = 1, bool speak_result = false) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_input && c_form[control_index].type != ct_list || !c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		return c_form[control_index].search(text, dir, !speak_result);
	}
	int get_progress(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return -1;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return -1;
		}
		if (c_form[control_index].type != ct_progress) {
			form_error = form_error_invalid_control;
			return -1;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return -1;
		}
		return c_form[control_index].progress;
	}
	int get_control_type(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return -1;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return -1;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return -1;
		}
		return c_form[control_index].type;
	}
	string get_control_attributes(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return "";
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return "";
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return "";
		}
		return c_form[control_index].type_to_name();
	}
	int get_control_count() {
		form_error = 0;
		return control_counter + 1;
	}
	int get_current_focus() {
		if (!active) {
			form_error = form_error_no_window;
			return -1;
		}
		for (int counter = 0; counter < c_form.length(); counter++) {
			if (c_form[counter].focused == true)
				return counter;
		}
		return -1;
	}
	int get_last_error() {
		return form_error;
	}
	bool set_link_url(int control_index, string new_url) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_link) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_index].link_url = new_url;
		return true;
	}
	string get_link_url(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return "";
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return "";
		}
		if (c_form[control_index].type != ct_link) {
			form_error = form_error_invalid_control;
			return "";
		}
		return c_form[control_index].link_url;
	}
	bool set_progress(int control_index, int value) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_progress) {
			form_error = form_error_invalid_control;
			return false;
		}
		if ((value < 0) || (value > 100)) {
			form_error = form_error_invalid_value;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_index].progress = value;
		if (c_form[control_index].speak_interval == 0) {
			if (c_form[control_index].speak_global == true)
				c_form[control_index].speak_progress();
			else {
				if (c_form[control_index].focused == true)
					c_form[control_index].speak_progress();
			}
		}
		return true;
	}
	bool set_slider(int control_index, double value, double min = -1, double max = -1) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_slider) {
			form_error = form_error_invalid_control;
			return false;
		}
		if ((min > -1 || max > -1) && max < min) {
			form_error = form_error_invalid_value;
			return false;
		}
		if (min > -1 && max > -1) {
			c_form[control_index].slider_minimum_value = min;
			c_form[control_index].slider_maximum_value = max;
		}
		if ((value < c_form[control_index].slider_minimum_value) || (value > c_form[control_index].slider_maximum_value)) {
			form_error = form_error_invalid_value;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_index].slider_value = value;
		return true;
	}
	double get_slider(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return -1;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return -1;
		}
		if (c_form[control_index].type != ct_slider) {
			form_error = form_error_invalid_control;
			return -1;
		}
		return c_form[control_index].slider_value;
	}
	string get_slider_text_value(int control_index, double value) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return -1;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return -1;
		}
		if (c_form[control_index].type != ct_slider) {
			form_error = form_error_invalid_control;
			return -1;
		}
		string text = "";
		if (c_form[control_index].slider_text_values.get(value, text)) return "";
		return text;
	}
	bool set_slider_step_size(int control_index, double new_size) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_slider) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (new_size <= 0) {
			form_error = form_error_invalid_value;
			return false;
		}
		c_form[control_index].slider_step_size = new_size;
		return true;
	}
	double get_slider_step_size(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return -1;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return -1;
		}
		if (c_form[control_index].type != ct_slider) {
			form_error = form_error_invalid_control;
			return -1;
		}
		return c_form[control_index].slider_step_size;
	}
	bool set_slider_text_value(int control_index, double value, const string& in text) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_slider) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (text == "")
			return c_form[control_index].slider_text_values.delete(value);
		else {
			c_form[control_index].slider_text_values.set(value, text);
			return true;
		}
	}
	bool clear_slider_text_values(int control_index) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (c_form[control_index].type != ct_slider) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_index].slider_text_values.delete_all();
		return true;
	}
	bool set_speech_verbosity_options(int control_index, string highlight_selection, string highlight_unselection, string deletion, string percentage, int keyboard_echo) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_index].highlight_selection_speech_text = highlight_selection;
		c_form[control_index].highlight_unselection_speech_text = highlight_unselection;
		c_form[control_index].percentage_speech_text = percentage;
		c_form[control_index].delete_speech_text = deletion;
		c_form[control_index].echo_flag = keyboard_echo;
		return true;
	}
	bool set_keyboard_echo(int control_index, int keyboard_echo) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if ((control_index < 0) || (control_index > c_form.length() - 1)) {
			form_error = form_error_invalid_index;
			return false;
		}
		if (!c_form[control_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		c_form[control_index].echo_flag = keyboard_echo;
		return true;
	}
	bool set_default_keyboard_echo(int keyboard_echo, bool update_controls = true) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if (update_controls) {
			for (int counter = 0; counter < c_form.length(); counter++)
				c_form[counter].echo_flag = keyboard_echo;
		}
		default_echo_flag = keyboard_echo;
		return true;
	}
	bool set_tts_object(tts_voice@ handle) {
		if (@handle == null) {
			tts_voice temp_voice;
			@ui_speech = temp_voice;
			return true;
		}
		@ui_speech = @handle;
		return true;
	}
	void reset(bool reset_to_default_keyboard_echo = true) {
		form_error = 0;
		if (reset_to_default_keyboard_echo) default_echo_flag = audioform_keyboard_echo;
		active = false;
		control_focus = -1;
		control_counter = -1;
		active_controls = -1;
		speech_output = 0;
		c_form.resize(0);
		@ui_speech = null;
		@event_callback = null;
		@utility_form = null;
	}
	//internal methods:
	private void set_primary(int control, bool state, bool overwrite) {
		int defaults = get_default_button();
		if (!state) {
			c_form[control].primary = state;
			return;
		}
		if (defaults == -1) {
			c_form[control].primary = state;
			return;
		}
		if (!overwrite)
			return;
		c_form[control].primary = state;
		if (defaults != control)
			c_form[defaults].primary = false;
	}
	private void set_cancel(int control, bool state, bool overwrite) {
		int cancels = get_cancel_button();
		if (!state) {
			c_form[control].cancel = state;
			return;
		}
		if (cancels == -1) {
			c_form[control].cancel = state;
			return;
		}
		if (!overwrite)
			return;
		c_form[control].cancel = state;
		if (cancels != control)
			c_form[cancels].cancel = false;
	}
	private bool focus(int tab_index, bool interrupt_previous_speech, bool silent = false) {
		form_error = 0;
		if (!active) {
			form_error = form_error_no_window;
			return false;
		}
		if (tab_index<0 or tab_index >= c_form.length()) return false;
		if (!c_form[tab_index].visible) {
			form_error = form_error_control_invisible;
			return false;
		}
		if (tab_index > c_form.length() - 1) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (!c_form[tab_index].active) {
			form_error = form_error_invalid_control;
			return false;
		}
		if (@c_form[tab_index].event_callback != null)
			c_form[tab_index].event_callback(this, tab_index, event_focus, {{"interrupt_previous_speech", interrupt_previous_speech}, {"silent", silent}});
		control_focus = tab_index;
		c_form[tab_index].focus(interrupt_previous_speech, speak_control_attributes_separately, silent);
		for (int counter = 0; counter < c_form.length(); counter++) {
			if (counter == tab_index)
				continue;
			c_form[counter].focused = false;
		}
		return true;
	}
	private void check(int tab_index) {
		if (c_form[tab_index].type == ct_input or c_form[tab_index].type == ct_list) {
			if (keyboard_modifiers & KEYMOD_CTRL != 0 and key_pressed(KEY_G) and c_form[tab_index].enable_go_to_index)
				go_to_index(this, tab_index);
		}
		if ((c_form[tab_index].type == ct_input && c_form[tab_index].multiline && c_form[tab_index].text != "") or c_form[tab_index].type == ct_list) {
			if (keyboard_modifiers & KEYMOD_CTRL != 0 and key_pressed(KEY_F))
				search_for(this, tab_index);
			else if (key_repeating(KEY_F3)) {
				string last_search = "";
				if (utility_form_data.get("last_search", last_search))
					c_form[tab_index].search(last_search, keyboard_modifiers & KEYMOD_SHIFT == 0 ? 1 : -1, false);
				else
					search_for(this, tab_index);
			}
		}
		if (c_form[tab_index].type == ct_input) {
			if (key_repeating(KEY_F2)) {
				int dir = 1;
				if (keyboard_modifiers & KEYMOD_SHIFT != 0) dir = -1;
				audioform_keyboard_echo = audioform_change_keyboard_echo(audioform_keyboard_echo, dir);
				this.set_default_keyboard_echo(audioform_keyboard_echo);
				speak(audioform_keyboard_echo_string(audioform_keyboard_echo));
			}
		}
		if (@utility_form == null)
			c_form[tab_index].check(this, tab_index);
	}
	private bool check_globals(bool required_setting) {
		if (!required_setting)
			return false;
		for (int counter = 0; counter < c_form.length(); counter++) {
			if ((c_form[counter].type == ct_progress) && (c_form[counter].speak_global))
				return false;
		}
		return true;
	}
	private void check_speech_mode() {
		for (int counter = 0; counter < c_form.length(); counter++) {
			if (c_form[counter].speech_output == speech_output)
				continue;
			c_form[counter].speech_output = speech_output;
		}
	}
	bool check_shortcuts(bool for_subform = false) {
		for (int counter = 0; counter < c_form.length(); counter++) {
			if (c_form[counter].hotkey_letter == "")
				continue;
			if (letter_to_key(c_form[counter].hotkey_letter) != c_form[counter].hotkey) {
				c_form[counter].hotkey_letter = "";
				c_form[counter].hotkey = -1;
				continue;
			}
			bool ralt = true;
			int current_form_focus = current_form.get_current_focus();
			if (audioform_input_disable_ralt && current_form_focus > -1 and current_form_focus < current_form.get_control_count() and current_form.get_control_type(current_form_focus) == ct_input and !c_form[control_focus].read_only)
				ralt = false;
			if ((key_down(KEY_LALT) || ralt && key_down(KEY_RALT)) && (key_repeating(c_form[counter].hotkey))) {
				if (!for_subform)
					focus(counter, true);
				else
					focus_silently(counter);
				return true;
			}
		}
		for (int i = 0; i <= control_counter; i++) {
			if (@c_form[i].subform != null and c_form[i].subform.check_shortcuts(true)) {
				focus(i);
				return true;
			}
		}
		return false;
	}
	private int shortcut(string caption_text) {
		for (int counter = 0; counter < caption_text.length(); counter++) {
			if (caption_text[counter] != "&")
				continue;
			if (counter == caption_text.length() - 1)
				return -1;
			else
				return letter_to_key(caption_text[counter + 1]);
		}
		return -1;
	}
	private string shortcut_letter(string caption_text) {
		for (int counter = 0; counter < caption_text.length(); counter++) {
			if (caption_text[counter] != "&")
				continue;
			if (counter == caption_text.length() - 1)
				return "";
			else
				return caption_text[counter + 1];
		}
		return "";
	}
	private int letter_to_key(string char) {
		if (char.length() != 1)
			char = char.substr(0, 1);
		if (!char.is_alphanumeric())
			return -1;
		char = char.lower();
		if (char == "a")
			return KEY_A;
		if (char == "b")
			return KEY_B;
		if (char == "c")
			return KEY_C;
		if (char == "d")
			return KEY_D;
		if (char == "e")
			return KEY_E;
		if (char == "f")
			return KEY_F;
		if (char == "g")
			return KEY_G;
		if (char == "h")
			return KEY_H;
		if (char == "i")
			return KEY_I;
		if (char == "j")
			return KEY_J;
		if (char == "k")
			return KEY_K;
		if (char == "l")
			return KEY_L;
		if (char == "m")
			return KEY_M;
		if (char == "n")
			return KEY_N;
		if (char == "o")
			return KEY_O;
		if (char == "p")
			return KEY_P;
		if (char == "q")
			return KEY_Q;
		if (char == "r")
			return KEY_R;
		if (char == "s")
			return KEY_S;
		if (char == "t")
			return KEY_T;
		if (char == "u")
			return KEY_U;
		if (char == "v")
			return KEY_V;
		if (char == "w")
			return KEY_W;
		if (char == "x")
			return KEY_X;
		if (char == "y")
			return KEY_Y;
		if (char == "z")
			return KEY_Z;
		if (char == "0")
			return KEY_0;
		if (char == "1")
			return KEY_1;
		if (char == "2")
			return KEY_2;
		if (char == "3")
			return KEY_3;
		if (char == "4")
			return KEY_4;
		if (char == "5")
			return KEY_5;
		if (char == "6")
			return KEY_6;
		if (char == "7")
			return KEY_7;
		if (char == "8")
			return KEY_8;
		if (char == "9")
			return KEY_9;
		return -1;
	}
	audio_form@ get_current_form() property {
		int focus = get_current_focus();
		if (focus > -1 && focus < c_form.length() && c_form[focus].type == ct_form) return c_form[focus].subform;
		return this;
	}

	/*
	private bool speak(string text, bool interrupt)
	{
	if((speech_output<=0)||(speech_output>4))
	{
	if(interrupt)
	{
	return ui_speech.speak_interrupt(text);
	}
	return ui_speech.speak(text);
	}
	if(interrupt)
	{
	return screen_reader_speak_interrupt(speech_output, text);
	}
	return screen_reader_speak(speech_output, text);
	}
	*/
	//internal properties
	bool subform = false;
	private int speech_output;
	int default_echo_flag = audioform_keyboard_echo;
	private control[] c_form;
	private int form_error;
	private int control_counter;
	private int active_controls;
	private int control_focus;
	private tts_voice@ ui_speech;
}
//Control class
//This is an internal class and should not be used by the application.
class control {
	string caption;
	string text;
	string custom_type;
	string link_url;
	string password_mask;
	string highlight_selection_speech_text;
	string highlight_unselection_speech_text;
	string percentage_speech_text;
	string delete_speech_text;
	string hotkey_letter;
	list_item[] list;
	bool list_multiselect;
	bool list_repeat_boundary_items;
	bool list_is_tab_panel;
	bool list_nav_translate;
	int type;
	int progress;
	double slider_value;
	double slider_minimum_value;
	double slider_maximum_value;
	double slider_step_size;
	dictionary slider_text_values;
	int echo_flag;
	int speak_interval;
	int speech_output;
	bool beeping_progress;
	int max_items;
	int hotkey;
	int list_index;
	int list_length;
	int list_position;
	int cursor;
	int sel_start;
	int sel_end;
	int max_length;
	bool speak_global;
	bool visible;
	bool enabled;
	bool checked;
	bool overwrite;
	bool read_only;
	bool multiline;
	bool multiline_enter;
	bool pressed;
	bool focused;
	bool primary;
	bool cancel;
	bool active;
	on_control_event_callback@ event_callback;
	//tone_synth beep;
	sound@ bar;
	timer progress_time;
	string multinav_characters;
	timer multinav_timer;
	bool multinav_letters;
	bool multinav_numbers;
	tts_voice@ ui_speech;
	audio_form@ subform = null;
	string[] disallowed_chars;
	bool use_only_disallowed_chars;
	string char_disallowed_description;
	bool enable_go_to_index; //This is mostly used on go to index field where it prevents the key from pressing again.
	control() {
		progress_time.restart();
		progress_time.pause();
		multinav_timer.restart();
		multinav_timer.pause();
		caption = "";
		text = "";
		password_mask = "";
		type = -1;
		cursor = 0;
		sel_start = -1;
		sel_end = -1;
		progress = 0;
		max_length = 0;
		echo_flag = textflag_characters;
		speak_interval = 5000;
		speech_output = 0;
		beeping_progress = false;
		max_items = 0;
		visible = true;
		multinav_letters = true;
		multinav_numbers = true;
		list_nav_translate = true;
		enabled = true;
		active = true;
		checked = false;
		read_only = false;
		multiline = false;
		multiline_enter = true;
		overwrite = false;
		pressed = false;
		focused = false;
		primary = false;
		cancel = false;
		speak_global = false;
		highlight_selection_speech_text = "Selected";
		highlight_unselection_speech_text = "Unselected";
		delete_speech_text = "";
		percentage_speech_text = "Percent";
		hotkey = -1;
		hotkey_letter = "";
		list.resize(0);
		list_index = -1;
		list_length = -1;
		list_position = -1;
		list_repeat_boundary_items = false;
		@ui_speech = null;
		this.disallowed_chars.resize(0);
		this.use_only_disallowed_chars = false;
		this.char_disallowed_description = "";
		this.enable_go_to_index = true;
	}
	void focus(bool interrupt_previous_speech, bool separate_attributes, bool silent = false) {
		if (silent == true) {
			focused = true;
			return;
		}
		if (type == ct_form && @subform != null) {
			if (caption != "") {
				if (interrupt_previous_speech == true)
					speak(caption, true);
				else
					speak(caption, false);
			}
			int f = subform.get_current_focus();
			if (f < 0) f = 0;
			subform.focus(f);
			focused = true;
			return;
		}
		string typename = type_to_name();
		string hotkey_text = "";
		if (hotkey_letter != "")
			hotkey_text = " Alt+" + hotkey_letter;
		if (separate_attributes == true) {
			if (interrupt_previous_speech == true)
				speak(caption, true);
			else
				speak(caption, false);
			speak(typename, false);
		} else {
			if (interrupt_previous_speech == true)
				speak(caption + " " + typename + hotkey_text, true);
			else
				speak(caption + " " + typename + hotkey_text, false);
		}
		if (hotkey_letter != "" && separate_attributes == true)
			speak("Alt+" + hotkey_letter, false);
		if ((type == ct_input) && (password_mask != "")) {
			if (text.length() > 0)
				speak(text.length() + " characters", false);
			else
				speak("Blank", false);
		}
		if ((type == ct_input) && (password_mask == "")) {
			if (text.length() > 0) {
				if (sel_start >= 0) {
					if (sel_end - sel_start >= 1024)
						speak(highlight_selection_speech_text + " " + (sel_end - sel_start + 1) + " characters", false);
					else
						speak(highlight_selection_speech_text + " " + text.substr(sel_start, sel_end - sel_start + 1), false);
				} else
					speak(read_line(current_line_start_position()), false);
			} else
				speak("Blank", false);
		}
		if (type == ct_status_bar)
			speak(text, false);
		if (type == ct_progress)
			speak_progress(false);
		if (type == ct_slider)
			speak(slider_value_string(), false);
		if ((type == ct_list) && (list_position > -1)) speak_list_item(false);
		focused = true;
	}
	bool is_disallowed_char(string char, bool search_all = true) {
		if (char.length() < 1)
			return false;
		if (search_all) {
			for (uint i = 0; i < char.length(); i++) {
				if (this.disallowed_chars.find(char[i]) < 0 && this.use_only_disallowed_chars) return true;
				else if (this.disallowed_chars.find(char[i]) > -1 && !this.use_only_disallowed_chars) return true;
			}
			return false;
		}
		return (this.disallowed_chars.find(char) > -1 && !this.use_only_disallowed_chars) or (this.disallowed_chars.find(char) < 0 && this.use_only_disallowed_chars);
	}
	void check(audio_form@ f, int tab_index) {
		string char;
		char = get_characters();
		if ((type == ct_input) && key_up(KEY_LALT) && (focused)) {
			if (!read_only) {
				if (char != "") {
					if (this.disallowed_chars.length() > 0 && this.is_disallowed_char(char)) {
						if (this.char_disallowed_description != "") speak(this.char_disallowed_description);
						return;
					}
					if (overwrite)
						edit(char);
					else
						add(char);
				}
				if (((key_down(KEY_LCTRL)) || (key_down(KEY_RCTRL))) && (key_repeating(KEY_X)) && password_mask == "")
					cut_highlighted();
				if (((key_down(KEY_LCTRL)) || (key_down(KEY_RCTRL))) && (key_repeating(KEY_V)) || key_pressed(KEY_PASTE))
					paste_text();
				if (key_repeating(KEY_BACK)) {
					if ((key_down(KEY_LCTRL) || key_down(KEY_RCTRL)) && (sel_start < 0 || sel_end < 0 || sel_start > sel_end)) {
						delete_word_left();
						return;
					}
					delete_highlighted();
				}
				if (key_repeating(KEY_DELETE)) {
					if ((key_down(KEY_LCTRL) || key_down(KEY_RCTRL)) && (sel_start < 0 || sel_end < 0 || sel_start > sel_end)) {
						delete_word_right();
						return;
					}
					delete_highlighted(1);
				}
				if (multiline == true && (multiline_enter == true || (key_down(KEY_LCTRL)) || (key_down(KEY_RCTRL)) || (key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT))) && ((key_repeating(KEY_RETURN)) || (key_repeating(KEY_NUMPAD_ENTER))))
					add_new_line();
			}
			if (((key_down(KEY_LCTRL)) || (key_down(KEY_RCTRL))) && key_up(KEY_LSHIFT) && key_up(KEY_RSHIFT) && (key_repeating(KEY_A)))
				highlight_all();
			if (((key_down(KEY_LCTRL)) || (key_down(KEY_RCTRL))) && (key_repeating(KEY_C)) && (password_mask == ""))
				copy_highlighted();
			if (key_repeating(KEY_LEFT)) {
				if ((key_down(KEY_LCTRL)) || (key_down(KEY_RCTRL))) {
					if (password_mask == "") {
						if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT)))
							move_word_left(true);
						else
							move_word_left();
					}
					return;
				}
				if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT))) {
					highlight_left();
					return;
				}
				move_left();
			}
			if (key_repeating(KEY_RIGHT)) {
				if ((key_down(KEY_LCTRL)) || (key_down(KEY_RCTRL))) {
					if (password_mask == "") {
						if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT)))
							move_word_right(true);
						else
							move_word_right();
					}
					return;
				}
				if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT))) {
					highlight_right();
					return;
				}
				move_right();
			}
			if (key_repeating(KEY_UP)) {
				if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT)) && password_mask == "")
					highlight_up();
				else
					previous_line();
			}
			if (key_repeating(KEY_DOWN)) {
				if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT)) && password_mask == "")
					highlight_down();
				else
					next_line();
			}
			if (key_repeating(KEY_HOME)) {
				if ((key_down(KEY_LCTRL)) || (key_down(KEY_RCTRL)) || (multiline == false)) {
					if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT)))
						highlight_to_field_start();
					else {
						if (!multiline)
							line_start();
						else
							field_start();
					}
				} else {
					if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT)))
						highlight_to_line_start();
					else
						line_start();
				}
			}
			if (key_repeating(KEY_END)) {
				if ((key_down(KEY_LCTRL)) || (key_down(KEY_RCTRL)) || (multiline == false)) {
					if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT)))
						highlight_to_field_end();
					else {
						if (!multiline)
							line_end();
						else
							field_end();
					}
				} else {
					if ((key_down(KEY_LSHIFT)) || (key_down(KEY_RSHIFT)))
						highlight_to_line_end();
					else
						line_end();
				}
			}
		}
		if (type == ct_button) {
			if (key_repeating(KEY_SPACE)) {
				int stop = @event_callback != null ? event_callback(f, tab_index, event_button, {}) : 0;
				if (stop == 0) {
					stop_speech();
					pressed = true;
				}
			}
		}
		if (type == ct_slider) {
			double increment = 0;
			// we don't want to add to the slider_value if it touches the edges.
			bool slider_edge = false;
			if (key_repeating(KEY_LEFT) || key_repeating(KEY_DOWN))
				increment = -slider_step_size;
			else if (key_repeating(KEY_RIGHT) || key_repeating(KEY_UP))
				increment = slider_step_size;
			else if (key_repeating(KEY_PAGEUP))
				increment = 5 * slider_step_size;
			else if (key_repeating(KEY_PAGEDOWN))
				increment = 5 * -slider_step_size;
			else if (key_repeating(KEY_HOME)) {
				increment = slider_maximum_value;
				slider_edge = true;
			} else if (key_repeating(KEY_END)) {
				increment = slider_minimum_value;
				slider_edge = true;
			} else
				return;
			int width = floor((slider_maximum_value - slider_minimum_value) / slider_step_size);
			if (keyboard_modifiers & KEYMOD_CTRL == 0 && width > 100 && !slider_edge) {
				increment *= (width * 0.025);
				// Because we now support doubles, increment multiplication can return numbers with decimal points.
				// It can set unexpected values if step size is without decimal points.
				if (slider_step_size % 1 == 0)
					increment -= increment % 1;
			}
			double new_value;
			if (slider_edge)
				new_value = increment;
			else
				new_value = (increment != 0) ? slider_value + increment : 0;
			if (new_value < slider_minimum_value)
				new_value = slider_minimum_value;
			if (new_value > slider_maximum_value)
				new_value = slider_maximum_value;
			if (new_value != slider_value) {
				double old = slider_value;
				slider_value = new_value;
				if (@event_callback != null and event_callback(f, tab_index, event_slider, {{"increment", increment}, {"value", slider_value}}) == 1) {
					slider_value = old;
					return;
				}
				speak(slider_value_string(), true);
			}
		}
		if (type == ct_list) {
			if (list_length == -1)
				return;
			if (multinav_characters != "" && multinav_timer.elapsed > 1000) {
				multinav_timer.pause();
				multinav_characters = "";
			}
			if ((key_down(KEY_LSHIFT) || key_down(KEY_RSHIFT)) && (char.is_alphabetic() || char.is_digits())) char = "";
			if (char != "" && key_up(KEY_LALT) && key_up(KEY_RALT) && key_up(KEY_LCTRL) && key_up(KEY_RCTRL) && (multinav_letters && char.is_alphabetic() || multinav_numbers && char.is_digits() || char == "-" || char == "_")) {
				char = char.lower();
				if (multinav_characters != char)
					multinav_characters += char;
				multinav_timer.restart();
				int old_list_position = list_position;
				if (list_position > -1 && multinav_characters.length() > utf8size(multinav_characters) && list[list_position].item.lower().substr(0, multinav_characters.length()) == multinav_characters)
					return;
				string[] nav_items(list.length());
				for (int i = 0; i < list.length(); i++)
					nav_items[i] = list[i].item;
				bool speak_pos = false;
				for (int i = list_position + 1; i <= list_length; i++) {
					if (nav_items[i].lower().substr(0, multinav_characters.length()) == multinav_characters) {
						list_position = i;
						speak_pos = true;
						break;
					}
				}
				if (list_position == old_list_position) {
					for (int i = 0; i <= list_position; i++) {
						if (nav_items[i].lower().substr(0, multinav_characters.length()) == multinav_characters) {
							list_position = i;
							speak_pos = true;
							break;
						}
					}
				}
				if (@event_callback != null and list_position != old_list_position) {
					dictionary args = {{"multinav", multinav_characters}};
					if (event_callback(f, tab_index, event_list_cursor, args) == 1) {
						list_position = old_list_position;
						speak_pos = false;
					}
					if (args.exists("silent")) speak_pos = false;
				}
				if (speak_pos) speak_list_item();
			}
			if (key_repeating(KEY_SPACE)) {
				if ((list_position == -1) || (!list_multiselect))
					return;
				if (list[list_position].checked) {
					list[list_position].checked = false;
					speak("Unchecked", true);
				} else {
					list[list_position].checked = true;
					speak("Checked", true);
				}
			}
			if (list_multiselect && (((key_down(KEY_LCTRL)) || (key_down(KEY_RCTRL))) && (key_repeating(KEY_A)))) {
				for (int counter = 0; counter <= list_length; counter++)
					list[counter].checked = true;
				speak("All items selected", true);
			}
			if (key_repeating(list_is_tab_panel ? KEY_LEFT : KEY_UP)) {
				if (list_position <= 0) {
					if (list_repeat_boundary_items && list_position == 0) {
						dictionary args = {{"key", KEY_UP}, {"boundary", true}};
						if (@event_callback != null and event_callback(f, tab_index, event_list_cursor, args) == 1) return;
						if (!args.exists("silent")) speak_list_item();
					}
					return;
				}
				list_position--;
				dictionary args = {{"key", KEY_UP}};
				if (@event_callback != null and event_callback(f, tab_index, event_list_cursor, args) == 1) {
					list_position++;
					return;
				}
				if (!args.exists("silent")) speak_list_item();
			}
			if (key_repeating(list_is_tab_panel ? KEY_RIGHT : KEY_DOWN)) {
				if (list_position >= list_length) {
					if (list_repeat_boundary_items && list_position == list.length() - 1) {
						dictionary args = {{"key", KEY_DOWN}, {"boundary", true}};
						if (@event_callback != null and event_callback(f, tab_index, event_list_cursor, args) == 1) return;
						if (!args.exists("silent")) speak_list_item();
					}
					return;
				}
				list_position++;
				dictionary args = {{"key", KEY_DOWN}};
				if (@event_callback != null and event_callback(f, tab_index, event_list_cursor, args) == 1) {
					list_position--;
					return;
				}
				if (!args.exists("silent")) speak_list_item();
			}
			if (key_repeating(KEY_HOME) && (list_position > 0 || list_repeat_boundary_items)) {
				int old_list_position = list_position;
				list_position = 0;
				dictionary args = {{"key", KEY_HOME}};
				if (@event_callback != null and event_callback(f, tab_index, event_list_cursor, args) == 1) {
					list_position = old_list_position;
					return;
				}
				if (!args.exists("silent")) speak_list_item();
			}
			if (key_repeating(KEY_END) && (list_position < list.length() - 1 || list_repeat_boundary_items)) {
				int old_list_position = list_position;
				list_position = list.length() - 1;
				dictionary args = {{"key", KEY_END}};
				if (@event_callback != null and event_callback(f, tab_index, event_list_cursor, args) == 1) {
					list_position = old_list_position;
					return;
				}
				if (!args.exists("silent")) speak_list_item();
			}
		}
		if (type == ct_checkbox) {
			if ((key_repeating(KEY_SPACE)) && (read_only == false)) {
				if (@event_callback != null and event_callback(f, tab_index, event_checkbox, {}) == 1) return;
				checkbox_toggle();
			}
		}
		if (type == ct_progress) {
			if (speak_interval == 0)
				return;
			if (progress_time.elapsed >= speak_interval) {
				progress_time.restart();
				if (progress == 100)
					progress_time.pause();
				if (focused == true)
					speak_progress();
			}
		}
		if (type == ct_link) {
			if (!key_pressed(KEY_SPACE) && !pressed)
				return;
			pressed = false;
			if (link_url.empty()) {
				speak("Error, link url is empty!");
				return;
			}
			if (regexp_match(link_url, "^(https?:\/\/)?(?:[a-zA-Z0-9_-]+(?::[a-zA-Z0-9._%+-]+)?@)?([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})(:\d{2,5})?(\/[^\s?#]*)?(\?[^\s#]*)?(#[^\s]*)?$")) {
			speak("Invalid url (%0)".format(link_url));
				return;
			}
			bool open_response = urlopen(link_url);
			speak(open_response ? "Opening %0".format(link_url) : "Couldn't open the url. Unexpected error occured!");
		}
	}
	string slider_value_string() {
		string text = "";
		if (!slider_text_values.get(slider_value, text))
			text = slider_value + this.text;
		return text;
	}
	int get_line_number() {
		if (type != ct_input) return 0;
		int ln = 1;
		for (uint i = 0; i < text.length() and i < cursor; i++) {
			if (text[i] == "\n") ln++;
		}
		return ln;
	}
	int get_line_column() {
		if (type != ct_input) return 0;
		int col = 1;
		for (int i = cursor - 1; i >= 0 and i < text.length(); i--) {
			if (text[i] == "\n") break;
			col++;
		}
		return col;
	}
	bool set_line(int line, int col = 1, bool silent = false) {
		if (type != ct_input) return false;
		if (col < 1) col = 1;
		int max_col = col;
		int pos = 0;
		if (line > 1)
			pos = bgt_string_contains(text, "\n", line - 1);
		if (pos > -1) {
			int pos2 = bgt_string_contains(text, "\n", line);
			if (pos2 > -1) max_col = pos2 - pos - 1;
		} else {
			if (!silent) speak("line number out of range");
			return false;
		}
		if (col > max_col) col = max_col;
		if (pos==0) col--;
		pos += col;
		cursor = pos;
		sel_start = -1;
		sel_end = -1;
		if (!silent) speak(read_line(current_line_start_position()), false);
		return true;
	}
	bool search(const string& in text, int dir = 1, bool silent = false) {
		if (type == ct_list) {
			if (list.length() < 1) return false;
			string[] nav_items(list.length());
			for (int i = 0; i < list.length(); i++)
				nav_items[i] = list[i].item;
			bool already_on_result = nav_items[list_position].find(text) > -1;
			string wrapped = "";
			for (int i = list_position + dir; i != list_position; i += dir) {
				if (i < 0) {
					i = list.length() - 1;
					wrapped = "wrapped to bottom";
				} else if (i >= list.length()) {
					i = 0;
					wrapped = "wrapped to top";
				}
				if (i == list_position) break;
				if (nav_items[i].find(text) < 0) continue;
				list_position = i;
				if (!silent) {
					if (wrapped != "") speak(wrapped);
					speak_list_item();
				}
				return true;
			}
			if (!silent)
				speak(already_on_result ? "nothing else found" : "nothing found");
			return false;
		} else if (type == ct_input) {
			string wrapped = "";
			int idx = dir > 0 ? this.text.find(text, cursor + dir) : this.text.rfind(text, cursor + dir);
			if (idx < 0) {
				int tmp_cursor = dir > 0 ? 0 : this.text.length() - 1;
				wrapped = dir > 0 ? "wrapped to top" : "wrapped to bottom";
				idx = dir > 0 ? this.text.find(text, tmp_cursor) : this.text.rfind(text, tmp_cursor);
			}
			if (idx < 0) {
				if (!silent) speak("nothing found");
				return false;
			}
			if (cursor == idx) {
				if (!silent) speak("nothing else found");
				return false;
			}
			cursor = idx;
			sel_start = -1;
			sel_end = -1;
			if (!silent) {
				if (wrapped != "") speak(wrapped);
				speak(read_line(current_line_start_position()), wrapped == "");
			}
			return true;
		} else
			return false;
	}
	void highlight_left() {
		if (cursor <= 0)
			return;
		if (sel_start < 0) {
			sel_start = utf8prev(text, cursor);
			sel_end = sel_start;
			speak(input_box_speak(find_appropriate_character(text.substr(sel_start, 4)), true) + " " + highlight_selection_speech_text, true);
			return;
		}
		int old_cursor = cursor;
		if (cursor > 0)
			cursor = utf8prev(text, cursor);
		if ((cursor == sel_start || old_cursor == sel_start) && sel_start > 0) {
			sel_start = utf8prev(text, sel_start);
			speak(input_box_speak(find_appropriate_character(text.substr(sel_start, 4)), true) + " " + highlight_selection_speech_text, true);
		} else if (cursor == sel_end || (old_cursor == sel_end) && sel_end > 0 && sel_end < text.length()) {
			speak(input_box_speak(find_appropriate_character(text.substr(sel_end, 4)), true) + " " + highlight_unselection_speech_text, true);
			sel_end = utf8prev(text, sel_end);
		}
		if (sel_end < sel_start && sel_start > -1) {
			sel_start = -1;
			sel_end = -1;
		}
	}
	void highlight_right() {
		if (text == "")
			return;
		if (sel_start == -1 && sel_end == -1 && cursor < text.length()) {
			sel_start = cursor;
			sel_end = cursor;
			speak(input_box_speak(find_appropriate_character(text.substr(sel_start, 4)), true) + " " + highlight_selection_speech_text, true);
			cursor = utf8next(text, cursor);
			return;
		}
		if (utf8prev(text, cursor) == sel_end && cursor < text.length()) {
			sel_end = utf8next(text, sel_end);
			speak(input_box_speak(find_appropriate_character(text.substr(sel_end, 4)), true) + " " + highlight_selection_speech_text, true);
		} else if ((cursor == sel_start || utf8prev(text, cursor) == sel_start) && cursor <= text.length() && sel_start > -1) {
			speak(input_box_speak(find_appropriate_character(text.substr(sel_start, 4)), true) + " " + highlight_unselection_speech_text, true);
			sel_start = utf8next(text, sel_start);
		}
		if (cursor < text.length())
			cursor = utf8next(text, cursor);
		if (sel_end < sel_start && sel_start > -1) {
			sel_start = -1;
			sel_end = -1;
		}
	}
	void next_line() {
		sel_start = -1;
		sel_end = -1;
		if (!multiline) {
			cursor = text.length();
			speak(read_line(0), true, false);
			return;
		}
		int line_start = current_line_start_position();
		if (line_start == text.length() || line_start < 0) {
			speak("Blank", true);
			if (line_start == text.length())
				cursor = text.length();
			return;
		}
		for (int counter = cursor; counter < text.length(); counter++) {
			if (text[counter] != "\n")
				continue;
			cursor = counter + 1;
			speak(read_line(cursor), true, false);
			return;
		}
		speak(read_line(line_start), true, false);
		cursor = text.length();
	}
	void previous_line() {
		sel_start = -1;
		sel_end = -1;
		int line_start = current_line_start_position();
		if (line_start <= 0 || !multiline) {
			cursor = 0;
			if (text == "")
				speak("Blank");
			else
				speak(read_line(0), true, false);
			return;
		}
		cursor = line_start - 1;
		cursor = current_line_start_position();
		if (cursor < 0)
			cursor = 0;
		speak(read_line(cursor), true, false);
	}
	void highlight_all() {
		if (text == "") {
			sel_start = -1;
			sel_end = -1;
			speak("nothing to select");
			return;
		}
		sel_start = 0;
		sel_end = text.length() - 1;
		cursor = 0;
		speak_selected(text);
	}
	private void speak_selected(const string& in selection) {
		if (selection.length() >= 1024 || password_mask != "")
			speak(selection.length() + " characters " + highlight_selection_speech_text);
		else
			speak(selection + " " + highlight_selection_speech_text, true, false);
	}
	void add(string character, bool silent = false) {
		if(type != ct_input)
		return;
		string new_text = text;
		if (sel_start > -1 && sel_end > -1) {
			cursor = sel_start;
			new_text = text.substr(0, cursor) + text.substr(sel_end + 1);
			sel_start = -1;
			sel_end = -1;
		}
		if ((max_length > 0) && (new_text.length() >= max_length))
			return;
		new_text = new_text.substr(0, cursor) + character + new_text.substr(cursor);
		if (read_only == false) {
			text = new_text;
			cursor += character.length();
		}
		if (echo_flag == textflag_characters || echo_flag == textflag_characters_words)
			speak(input_box_speak(find_appropriate_character(character)), true);
		if (audioform_word_separators .find(character) > -1 && (echo_flag == textflag_words || echo_flag == textflag_characters_words)) {
			int temp_position = cursor - 1;
			while (temp_position > 0 && (temp_position >= text.length() || audioform_word_separators .find(text[temp_position - 1]) < 0 && text[temp_position - 1] != "\n"))
				temp_position--;
			string word = read_word_from_position(temp_position);
			if (password_mask != "") {
				for (uint i = 0; i < word.length(); i++) word[i] = password_mask;
			}
			speak(word, echo_flag != textflag_characters_words);
		}
	}
	void edit(string character) {
		if ((max_length > 0) && (text.length() > max_length))
			return;
		if (text.length() == 0)
			return;
		if (cursor >= text.length())
			return;
		if (read_only == false)
			text[cursor] = character;
		if (echo_flag == textflag_characters || echo_flag == textflag_characters_words)
			speak(input_box_speak(find_appropriate_character(character)), true);
		if (audioform_word_separators .find(character) > -1 && (echo_flag == textflag_words || echo_flag == textflag_characters_words)) {
			int temp_position = cursor - 1;
			while (temp_position > 0 && (temp_position >= text.length() || audioform_word_separators .find(text[temp_position - 1]) < 0))
				temp_position--;
			speak(read_word_from_position(temp_position), echo_flag != textflag_characters_words);
		}
	}
	bool add_silent(string content, int position) {
		string new_text = "";
		if ((position < 0) || (position > text.length()))
			return false;
		if (position == text.length()) {
			new_text = text + content;
			if ((max_length > 0) && (new_text.length() > max_length))
				return false;
			text = new_text;
			return true;
		}
		new_text = text.substr(0, position) + content + text.substr(position);
		if ((max_length > 0) && (new_text.length() > max_length))
			return false;
		text = new_text;
		return true;
	}
	bool edit_silent(string content, int position, int edit_mode) {
		if (edit_mode == edit_mode_replace)
			return replace_text(content, position);
		if (edit_mode == edit_mode_trim_to_length)
			return trim_to_length(content, position);
		if (edit_mode == edit_mode_append_to_end)
			return append_text(content, position);
		return false;
	}
	bool replace_text(string content, int position) {
		if (position >= text.length())
			return false;
		if (position == 0) {
			if ((max_length > 0) && (content.length() > max_length))
				return false;
			text = content;
			return true;
		}
		string new_text = text.substr(0, position);
		new_text += content;
		if ((max_length > 0) && (new_text.length() > max_length))
			return false;
		text = new_text;
		return true;
	}
	bool trim_to_length(string content, int position) {
		if (position >= text.length())
			return false;
		for (int counter = position; counter < text.length(); counter++) {
			if (content == "")
				break;
			text[counter] = content[0];
			content = content.substr(1);
		}
		return true;
	}
	bool append_text(string content, int position) {
		if (position >= text.length())
			return false;
		if ((position == 0) && (content.length() > text.length())) {
			if ((max_length > 0) && (content.length() > max_length))
				return false;
			text = content;
			return true;
		}
		string new_text = text;
		for (int counter = position; counter < new_text.length(); counter++) {
			if (content == "")
				break;
			new_text[counter] = content[0];
			content = content.substr(1);
		}
		new_text += content;
		if ((max_length > 0) && (new_text.length() > max_length))
			return false;
		text = new_text;
		return true;
	}
	void copy_highlighted() {
		if (sel_start < 0 || sel_end < 0 || sel_start > sel_end) {
			speak("Nothing selected", true);
			return;
		}
		string copy_text = text.substr(0, sel_end + 1).substr(sel_start);
		speak("Copied to clipboard", true);
		clipboard_set_text(copy_text);
	}
	void cut_highlighted() {
		if (read_only == true) {
			speak("Cannot cut from a read only edit box.", true);
			return;
		}
		if (sel_start < 0 || sel_end < 0 || sel_start > sel_end) {
			speak("Nothing selected", true);
			return;
		}
		string copy_text = text.substr(0, sel_end + 1).substr(sel_start);
		speak("Cut Selected", true);
		clipboard_set_text(copy_text);
		delete_highlighted(0, false);
	}
	void paste_text() {
		string paste = clipboard_get_text();
		string[]@ paste_single = paste.split("\r\n", false);
		if (!multiline)
			paste = paste_single[0];
		paste = paste.replace("\r", "", true);
		if (paste == "") {
			speak("clipboard empty", true);
			return;
		}
		if ((max_length > 0) && ((text + paste).length() - (sel_end - sel_start) > max_length)) {
			speak("clipboard data can't fit", true);
			return;
		}
		if (this.disallowed_chars.length() > 0 && this.is_disallowed_char(paste)) {
			if (this.char_disallowed_description != "") speak(this.char_disallowed_description);
			return;
		}
		string new_text = text;
		if (sel_start > -1 && sel_end > -1) {
			cursor = sel_start;
			new_text = text.substr(0, cursor) + text.substr(sel_end + 1);
			sel_start = -1;
			sel_end = -1;
		}
		text = new_text.substr(0, cursor) + paste + new_text.substr(cursor);
		cursor += paste.length();
		speak("Text Pasted", true);
	}
	void delete_word_left() {
		move_word_left(true, false);
		delete_highlighted(0, false);
	}
	void delete_word_right() {
		move_word_right(true, false);
		delete_highlighted(0, false);
	}
	void delete_highlighted() {
		delete_highlighted(0);
	}
	void delete_highlighted(int from_start) {
		delete_highlighted(from_start, true);
	}
	void delete_highlighted(int from_start, bool speak_deleted) {
		if ((text == "") || (read_only == true))
			return;
		if (sel_start > -1 && sel_end > -1 && sel_start <= sel_end) {
			cursor = sel_start;
			text = text.substr(0, cursor) + text.substr(sel_end + 1);
			sel_start = -1;
			sel_end = -1;
			if (speak_deleted)
				speak("selection deleted");
			return;
		} else if (from_start == 0 && cursor > 0) {
			int old_cursor = cursor;
			cursor = utf8prev(text, cursor);
			if (cursor >= text.length())
				cursor = text.length() - 1;
			if (speak_deleted)
				speak(input_box_speak(find_appropriate_character(text.substr(cursor, 4)), true) + (delete_speech_text != "" ? " " + delete_speech_text : ""), true);
			text = text.substr(0, cursor) + text.substr(old_cursor);
		} else if (from_start == 1) {
			string del_char = "Blank";
			if (cursor < text.length())
				del_char = text.substr(cursor, 4);
			text = text.substr(0, cursor) + text.substr(cursor + utf8size(text.substr(cursor, 1)));
			if (speak_deleted)
				speak(input_box_speak(find_appropriate_character(del_char), true), true);
		}
	}
	void move_left() {
		sel_start = -1;
		sel_end = -1;
		cursor = utf8prev(text, cursor);
		if (cursor < 0)
			cursor = 0;
		if (cursor >= text.length())
			speak("Blank");
		else
			speak(input_box_speak(find_appropriate_character(text.substr(cursor, 4)), true), true);
	}
	void move_right() {
		sel_start = -1;
		sel_end = -1;
		cursor = utf8next(text, cursor);
		if (cursor > text.length())
			cursor = text.length();
		if (cursor >= text.length())
			speak("Blank");
		else
			speak(input_box_speak(find_appropriate_character(text.substr(cursor, 4)), true), true);
	}
	void add_new_line() {
		if (multiline == false)
			return;
		add("\n");
		if (echo_flag != textflag_none)
			speak("New Line", true);
	}
	int current_line_start_position(bool word = false) {
		if (text == "")
			return -1;
		int i = cursor;
		while (i<text.length() and word and i >= 0 and audioform_word_separators .find(text[i]) > -1)
			i--;
		for (i; i > -1; i--) {
			if (i >= text.length() || i == cursor && !word && text[cursor] == "\n")
				continue;
			if (i <= 0) {
				if (i == 0 && text[i] == "\n")
					return i + 1;
				else
					return i;
			} else if (!word && text[i] == "\n" || (word && audioform_word_separators .find(text[i]) > -1))
				return i + 1;
		}
		return 0;
	}
	string type_to_name() {
		string name;
		if (!custom_type.empty())
			name = custom_type;
		else if (type == ct_button)
			name = "Button";
		else if (type == ct_list) {
			if (list_is_tab_panel) name = "Tab panel";
			else name = "List";
		}
		else if (type == ct_input) {
			if (multiline == false)
				name = "Edit";
			if (multiline == true)
				name = "Edit Multi Line";
			if (password_mask != "")
				name = name + " Characters Hidden";
		}
		else if (type == ct_checkbox) {
			if (checked)
				name = "Check Box Checked";
			else
				name = "Check Box Not Checked";
		}
		else if (type == ct_progress)
			name = "Progress Bar";
		else if (type == ct_slider)
			name = "Slider";
		else if (type == ct_status_bar)
			name = "Status Bar";
		else if (type == ct_keyboard_area)
			name = "Keyboard Area";
		else if (type == ct_link)
			name = "Link";
		if (enabled == false)
			name = "Disabled " + name;
		if (read_only == true)
			name = "Read Only " + name;
		return name;
	}
	string input_box_speak(string character) {
		return input_box_speak(character, false);
	}
	string input_box_speak(string character, bool ignore_echo_flag) {
		if (character == " ")
			return "Space";
		if (character == "\n")
			return "Blank";
		if (character == "-")
			return "Dash";
		if (character == ".")
			return "Dot";
		if (character == ",")
			return "Comma";
		if (character == "@")
			return "At";
		if (character == ">")
			return "Greater";
		if (character == ";")
			return "Semicolon";
		if (character == ":")
			return "Colon";
		if (character == "\t")
			return "Tab";
		if (character == "'")
			return "Apostrophe";
		if (character == "<")
			return "Less";
		if (character == "_")
			return "Underline";
		if (character == "+")
			return "Plus";
		if (character == "=")
			return "Equals";
		if (character == "!")
			return "Exclamation Mark";
		if (character == "\"")
			return "Quote";
		if (character == "\\")
			return "Backslash";
		if (character == "/")
			return "Slash";
		if (character == "£")
			return "Pounds";
		if (character == "$")
			return "Dollar";
		if (character == "%")
			return "Percent";
		if (character == "^")
			return "Carret";
		if (character == "&")
			return "And";
		if (character == "*")
			return "Star";
		if (character == "(")
			return "Left Parenthesis";
		if (character == ")")
			return "Right Parenthesis";
		if (character == "[")
			return "Left Bracket";
		if (character == "]")
			return "Right Bracket";
		if (character == "{")
			return "Left Brace";
		if (character == "}")
			return "Right Brace";
		if (character == "|")
			return "Bar";
		if (character == "?")
			return "Question Mark";
		if (character == "`")
			return "Grave";
		if (character == "¬")
			return "Not";
		if (character == "#")
			return "Number";
		if (character == "~")
			return "Tilda";
		if ((echo_flag == textflag_none) && (ignore_echo_flag == false))
			return "";
		if (character.is_alphanumeric()) {
			if (character.is_upper())
				return "Capital " + character + " ";
			else
				return character + " ";
		}
		return character + " ";
	}
	void checkbox_toggle() {
		if (checked == true) {
			checked = false;
			speak("Not Checked", true);
		} else {
			checked = true;
			speak("Checked", true);
		}
	}
	string find_appropriate_character(string original_character) {
		original_character.resize(utf8size(original_character));
		if (password_mask == "")
			return original_character;
		else
			return password_mask;
	}
	void speak_progress() {
		if (beeping_progress) {
			beep_progress();
			return;
		}
		speak_progress(true);
	}
	void speak_progress(bool interrupt) {
		speak("" + progress + " " + percentage_speech_text, interrupt);
	}
	void beep_progress() {
		string frequency = "";
		double freq = progress;
		freq = pow(2, double((freq + 1) / 100 * 6));
		freq *= 55;
		frequency = freq;
		//beep.reset();
		//beep.waveform_type = 4;
		//beep.freq_ms(frequency,40);
		//@bar=beep.write_wave_sound();
		if (!bar.active) {
			speak_progress(true);
			return;
		}
		bar.play();
	}
	string read_line(int position) {
		string temp = "";
		for (int counter = position; counter < text.length(); counter++) {
			if (text[counter] != "\n")
				temp += text[counter];
			else
				break;
		}
		if (temp == "")
			return "Blank";
		if (password_mask != "")
			return temp.length() + " characters";
		return temp;
	}
	void line_start() {
		if (cursor == 0) {
			if (text != "")
				speak(input_box_speak(find_appropriate_character(text.substr(0, 4)), true));
			else
				speak("Blank");
			return;
		}
		int line_start = current_line_start_position();
		if (line_start < text.length()) {
			cursor = line_start;
			speak(input_box_speak(find_appropriate_character(text.substr(cursor, 4)), true));
		}
		sel_start = -1;
		sel_end = -1;
	}
	void line_end() {
		int i = cursor;
		for (i = cursor; i <= text.length(); i++) {
			if (i == text.length() or text[i] == "\n") break;
		}
		cursor = i;
		speak("Blank");
		sel_start = -1;
		sel_end = -1;
	}
	void move_word_left(bool highlighting = false, bool speak_selection_status = true) {
		if (text == "") {
			if (speak_selection_status) speak("Blank");
			return;
		}
		if (highlighting) {
			if (cursor < 1)
				return;
			int pos = current_line_start_position(true);
			while (cursor == pos) {
				int tmp_cursor = cursor;
				cursor = pos - 2;
				pos = current_line_start_position(true);
				cursor = tmp_cursor;
			}
			if (sel_start == -1 && sel_end == -1 || cursor == sel_start || cursor - 1 == sel_start) {
				sel_start = pos;
				if (sel_end == -1)
					sel_end = cursor - 1;
				if (speak_selection_status) speak_selected(text.substr(sel_start, cursor - sel_start));
				else speak(text.substr(sel_start, cursor - sel_start), true, false);
				cursor = sel_start;
				return;
			} else if (cursor == sel_end || cursor - 1 == sel_end) {
				sel_end = pos - 1;
				if (speak_selection_status) speak(text.substr(pos, cursor - 1 - pos) + " " + highlight_unselection_speech_text, true, false);
				else speak(text.substr(pos, cursor - 1 - pos), true, false);
				cursor = pos;
				return;
			}
		}
		if (cursor <= 0) {
			speak(read_word_from_position(0), true, false);
			return;
		}
		int cur_word = current_line_start_position(true);
		while (cursor == cur_word) {
			int tmp_cursor = cursor;
			cursor = cur_word - 2;
			cur_word = current_line_start_position(true);
			cursor = tmp_cursor;
		}
		cursor = cur_word;
		speak(read_word_from_position(cur_word), true, false);
	}
	void move_word_right(bool highlighting = false, bool speak_selection_status = true) {
		if (text == "" || cursor < 0 || cursor >= text.length()) {
			if (speak_selection_status) speak("Blank");
			return;
		}
		bool found_boundary = audioform_word_separators .find(text[cursor]) > -1;
		int new_word = -1;
		for (uint i = cursor; i < text.length(); i++) {
			if (audioform_word_separators .find(text[i]) > -1)
				found_boundary = true;
			else if (found_boundary && audioform_word_separators .find(text[i]) < 0) {
				new_word = i;
				break;
			}
		}
		if (new_word == -1)
			new_word = text.length();
		//if(highlighting&&new_word>0)
		//new_word-=1;
		if (highlighting) {
			if (sel_start == -1 && sel_end == -1 || cursor == sel_end || cursor - 1 == sel_end) {
				if (sel_start == -1)
					sel_start = cursor;
				sel_end = new_word - 1;
				if (speak_selection_status) speak_selected(text.substr(cursor, new_word - cursor));
				else speak(text.substr(cursor, new_word - cursor), true, false);
				cursor = new_word;
				return;
			} else if (cursor == sel_start || cursor - 1 == sel_start) {
				if (speak_selection_status) speak(text.substr(sel_start, new_word - sel_start) + " " + highlight_unselection_speech_text, true, false);
				else speak(text.substr(sel_start, new_word - sel_start), true, false);
				sel_start = new_word;
				cursor = new_word;
				return;
			}
		}
		cursor = new_word;
		if (cursor < text.length())
			speak(read_word_from_position(cursor), true, false);
		else
			speak("Blank");
	}
	void field_start() {
		cursor = 0;
		sel_start = -1;
		sel_end = -1;
		if (text.length() == 0) {
			speak("Blank", true);
			return;
		}
		speak(read_line(0), true, false);
	}
	void field_end() {
		sel_start = -1;
		sel_end = -1;
		if (text.length() == 0) {
			speak("Blank", true);
			return;
		}
		cursor = text.length();
		int line_start = current_line_start_position();
		speak(read_line(line_start), true, false);
	}
	string read_word_from_position(int position) {
		if (text == "")
			return "";
		int word_end = 0;
		for (int counter = position; counter < text.length(); counter++) {
			if (word_end < 1 && (audioform_word_separators .find(text[counter]) > -1 || text[counter] == "\n"))
				word_end = counter;
			else if (word_end > 0 && (audioform_word_separators .find(text[counter]) < 0) && (text[counter] != "\n")) {
				word_end = counter;
				break;
			}
		}
		return text.substr(position, word_end - position);
	}
	void highlight_to_field_start() {
		if (cursor == 0)
			return;
		sel_start = 0;
		sel_end = cursor;
		cursor = 0;
		speak_selected(text.substr(0, sel_end + 1));
	}
	void highlight_to_field_end() {
		if (cursor >= text.length())
			return;
		sel_start = cursor;
		sel_end = text.length() - 1;
		cursor = text.length();
		speak_selected(text.substr(sel_start));
	}
	void highlight_to_word_start() {
	}
	void highlight_to_word_end() {
	}
	void highlight_to_line_start(bool continuation = false) {
		if (cursor == 0)
			return;
		if (cursor == text.length())
			cursor -= 1;
		if (cursor == text.length() - 1 && cursor >= 0 && text[cursor] == "\n" && !continuation)
			cursor -= 1;
		int line_start = current_line_start_position();
		if (cursor <= line_start) {
			if (!continuation)
				return;
			else {
				int tmp_cursor = cursor;
				cursor = line_start - 1;
				line_start = current_line_start_position();
				if (line_start < 0) line_start = 0;
				cursor = tmp_cursor;
			}
		}
		if (sel_start < 0 || cursor == sel_start || cursor - 1 == sel_start) {
			sel_start = line_start;
			if (!continuation || sel_end == -1)
				sel_end = cursor;
			speak_selected(text.substr(sel_start, cursor - sel_start));
			cursor = sel_start;
		} else if (cursor == sel_end || cursor - 1 == sel_end) {
			sel_end = line_start;
			speak(text.substr(sel_end, cursor - sel_end) + " " + highlight_unselection_speech_text, true, false);
			cursor = sel_end;
		}
		if (sel_end < sel_start) {
			sel_start = -1;
			sel_end = -1;
		}
	}
	void highlight_to_line_end(bool continuation = false) {
		if (cursor >= text.length() - 1)
			return;
		int line_end = cursor + 1;
		for (line_end; line_end < text.length(); line_end++) {
			if (text[line_end] == "\r" || text[line_end] == "\n")
				break;
		}
		if (sel_end == line_end) {
			if (!continuation)
				return;
			else {
				if (text[line_end] == "\r") line_end += 2;
				else if (text[line_end] == "\n") line_end += 1;
				for (line_end; line_end < text.length(); line_end++) {
					if (text[line_end] == "\r" || text[line_end] == "\n")
						break;
				}
			}
		}
		//line_end-=1;
		if (sel_start < 0 || cursor == sel_end || cursor - 1 == sel_end) {
			if (!continuation or sel_start == -1)
				sel_start = cursor;
			sel_end = line_end;
			int old_cursor = cursor;
			cursor = line_end;
			speak_selected(text.substr(old_cursor, sel_end - old_cursor));
		} else if (cursor == sel_start || cursor - 1 == sel_start) {
			sel_start = line_end;
			speak(text.substr(cursor, line_end - cursor) + " " + highlight_unselection_speech_text, true, false);
			cursor = line_end;
		}
		if (sel_end < sel_start) {
			sel_start = -1;
			sel_end = -1;
		}
	}
	void highlight_up() {
		highlight_to_line_start(true);
	}
	void highlight_down() {
		highlight_to_line_end(true);
	}
	void highlight_by_position(int start, int end) {
		sel_start = start;
		sel_end = end;
	}
	void speak_list_item(bool interrupt = true) {
		if (list_is_tab_panel) speak(list[list_position].item + " tab", (interrupt ? true : false));
		else if (!list_is_tab_panel and list[list_position].checked) speak(list[list_position].item + " Checked", (interrupt ? true : false));
		else speak(list[list_position].item, (interrupt ? true : false));
	}
	/*
	bool speak(string text, bool interrupt)
	{
	if((speech_output<=0)||(speech_output>4))
	{
	if(interrupt)
	{
	return ui_speech.speak_interrupt(text);
	}
	return ui_speech.speak(text);
	}
	if(interrupt)
	{
	return screen_reader_speak_interrupt(speech_output, text);
	}
	return screen_reader_speak(speech_output, text);
	}
	*/
}
class list_item {
	string item;
	string id;
	bool checked;
	list_item() {
		item = "";
		id = "";
		checked = false;
	}
}

//utility_form interface used for search and goto dialogs.
interface utility_form {
	void monitor();
}
class go_to_index : utility_form {
	audio_form@ parent;
	int control_index;
	audio_form f;
	int f_index, f_col, f_ok, f_cancel;
	go_to_index(audio_form@ parent, int control_index) {
		@this.parent = @parent;
		int type = parent.get_control_type(control_index);
		if (type < 0) return;
		this.control_index = control_index;
		if (type != ct_input and type != ct_list)
			return;
		int current = type == ct_list ? parent.get_list_position(control_index) + 1 : parent.get_line_number(control_index);
		f.create_window((type == ct_list ? "go to item" : "go to line"), false, true);
		f_index = f.create_input_box((type == ct_list ? "item number" : "line number"), current, "", 6);
		f.set_enable_go_to_index(f_index, false);
		f.select_text(f_index, 0, -1);
		int index_to_focus = f_index;
		if (type == ct_input) {
			f_col = f.create_input_box("line column", parent.get_line_column(control_index), "", 6);
			f.select_text(f_col, 0, -1);
			f.set_enable_go_to_index(f_col, false);
			if (!parent.is_multiline(control_index)) {
				index_to_focus = f_col;
				f.set_state(f_index, false, false); //Set to hidden because not multiline input.
			}
		}
		f_ok = f.create_button("ok", true);
		f_cancel = f.create_button("cancel", false, true);
		f.focus(index_to_focus);
		@parent.utility_form = this;
	}
	void monitor() {
		f.monitor();
		if (f.is_pressed(f_cancel)) {
			parent.focus_interrupt(control_index);
			@parent.utility_form = null;
		} else if (f.is_pressed(f_ok)) {
			string idx = f.get_text(f_index);
			if (!idx.is_digits() or idx.substr(0, 1) == "0") {
				speak("enter a positive number");
				f.focus(f_index);
				return;
			}
			if (parent.get_control_type(control_index) == ct_list) {
				if (!parent.set_list_position(control_index, parse_int(idx) - 1)) {
					speak("invalid item number!");
					f.focus(f_index);
				} else {
					@parent.utility_form = null;
					parent.focus_interrupt(control_index);
				}
				return;
			}
			string col = f.get_text(f_col);
			if (!col.is_digits()) {
				speak("enter a positive number");
				f.focus(f_col);
				return;
			}
			if (!parent.set_line(control_index, parse_int(idx), parse_int(col))) {
				speak("invalid line number!");
				f.focus(f_index);
			} else {
				@parent.utility_form = null;
				parent.focus_interrupt(control_index);
			}
		}
	}
}
class search_for : utility_form {
	audio_form@ parent;
	int control_index;
	audio_form f;
	int f_text, f_next, f_prev, f_cancel;
	search_for(audio_form@ parent, int control_index) {
		@this.parent = @parent;
		int type = parent.get_control_type(control_index);
		if (type < 0) return;
		this.control_index = control_index;
		if (type != ct_input and type != ct_list or parent.get_password_mask(control_index) != "") {
			if (type == ct_input)
				speak("this is a protected text field");
			return;
		}
		string current = "";
		parent.utility_form_data.get("last_search", current);
		f.create_window((type == ct_list ? "search for item" : "search for text"), false, true);
		f_text = f.create_input_box((type == ct_list ? "search for items containing text" : "search text"), current, "", 256);
		if (current != "")
			f.select_text(f_text, 0, current.length() - 1);
		f_next = f.create_button("find &next", true);
		f_prev = f.create_button("find &previous");
		f_cancel = f.create_button("cancel", false, true);
		f.focus(f_text);
		@parent.utility_form = this;
	}
	void monitor() {
		f.monitor();
		bool search_forward = f.is_pressed(f_next);
		if (f.is_pressed(f_cancel)) {
			parent.focus_interrupt(control_index);
			@parent.utility_form = null;
		} else if (search_forward or f.is_pressed(f_prev)) {
			string text = f.get_text(f_text);
			if (text == "") {
				speak("enter some text to search for");
				f.focus(f_text);
				return;
			}
			parent.utility_form_data.set("last_search", text);
			if (!parent.search(control_index, text, search_forward ? 1 : -1)) {
				speak("nothing found");
				f.focus(f_text);
			} else {
				@parent.utility_form = null;
				parent.focus_interrupt(control_index);
			}
		}
	}
}

//key_repeating globals and function
//This is global because it can be used in the application.
timer key_repeating_timer;
int key_repeating_last_key_pressed;
int key_repeating_status;
bool key_repeating(int key, int repeat_delay, int prerepeat_delay) {
	if (key_pressed(key)) {
		key_repeating_status = 1;
		key_repeating_last_key_pressed = key;
		key_repeating_timer.restart();
		return true;
	}
	if (key_repeating_last_key_pressed == key) {
		if (key_up(key) or !is_window_active()) {
			key_repeating_status = 0;
			key_repeating_last_key_pressed = 0;
			return false;
		} else {
			if (key_repeating_status == 1 && key_repeating_timer.elapsed >= prerepeat_delay || key_repeating_status == 2 && key_repeating_timer.elapsed >= repeat_delay) {
				if (key_repeating_status == 1)
					key_repeating_status = 2;
				key_repeating_timer.restart();
				return true;
			}
		}
	}
	return false;
}

// BGT's string_contains function takes a number of occurances as a second argument, while string.find takes an offset in bytes. A couple features in audio form use occurances, in which ase providing bgt_string_contains as a utility function is more useful than hacking it's functionality into the places in audio form that need it.
shared int bgt_string_contains(const string& in str, const string& in search, int occurance = 1) {
	uint c = 0;
	int pos = -1;
	while (c < occurance) {
		pos = str.find_first(search, pos + 1);
		if (pos > -1)
			c++;
		else
			break;
	}
	return c == occurance ? pos : -1;
}
//Wrapper functions for keyboard echo changing.
shared uint audioform_change_keyboard_echo(int keyboard_echo, int dir = 1) {
	keyboard_echo += dir;
	if (keyboard_echo < textflag_none) keyboard_echo = textflag_characters_words;
	else if (keyboard_echo > textflag_characters_words) keyboard_echo = textflag_none;
	return keyboard_echo;
}
shared string audioform_keyboard_echo_string(int keyboard_echo) {
	if (keyboard_echo == textflag_characters) return "characters";
	else if (keyboard_echo == textflag_words) return "words";
	else if (keyboard_echo == textflag_characters_words) return "characters and words";
	else return "none";
}
